//! TypeScript type generator for database schemas.
//!
//! Generates TypeScript interfaces and types from a DbSchema,
//! similar to what `supabase gen types typescript` produces.

use crate::schema::{ColumnInfo, CompositeTypeInfo, DbSchema, EnumInfo, TableInfo, ViewInfo};
use std::collections::BTreeMap;

/// Configuration for TypeScript generation.
#[derive(Debug, Clone)]
pub struct TypeScriptConfig {
    /// Whether to export types (add `export` keyword)
    pub export_types: bool,
    /// Whether to generate Row types for tables
    pub generate_row_types: bool,
    /// Whether to generate Insert types (optional fields for defaults)
    pub generate_insert_types: bool,
    /// Whether to generate Update types (all fields optional)
    pub generate_update_types: bool,
}

impl Default for TypeScriptConfig {
    fn default() -> Self {
        Self {
            export_types: true,
            generate_row_types: true,
            generate_insert_types: true,
            generate_update_types: true,
        }
    }
}

/// Generate TypeScript types from a database schema.
pub fn generate_typescript(schema: &DbSchema, config: &TypeScriptConfig) -> String {
    let mut output = String::new();

    // Header comment
    output.push_str("// This file is auto-generated by Supawatch. Do not edit manually.\n");
    output.push_str("// Generated from your local schema file.\n\n");

    // Group entities by schema
    let mut schemas: BTreeMap<String, SchemaEntities> = BTreeMap::new();

    // Collect tables
    for (key, table) in &schema.tables {
        let schema_name = normalize_schema_name(&table.schema);
        schemas
            .entry(schema_name)
            .or_default()
            .tables
            .insert(key.clone(), table.clone());
    }

    // Collect enums
    for (key, enum_info) in &schema.enums {
        let schema_name = normalize_schema_name(&enum_info.schema);
        schemas
            .entry(schema_name)
            .or_default()
            .enums
            .insert(key.clone(), enum_info.clone());
    }

    // Collect composite types
    for (key, comp) in &schema.composite_types {
        let schema_name = normalize_schema_name(&comp.schema);
        schemas
            .entry(schema_name)
            .or_default()
            .composite_types
            .insert(key.clone(), comp.clone());
    }

    // Collect views
    for (key, view) in &schema.views {
        let schema_name = normalize_schema_name(&view.schema);
        schemas
            .entry(schema_name)
            .or_default()
            .views
            .insert(key.clone(), view.clone());
    }

    // Generate types for each schema
    for (schema_name, entities) in &schemas {
        output.push_str(&format!("// Schema: {}\n", schema_name));
        output.push_str(&format!(
            "export namespace {} {{\n",
            to_pascal_case(schema_name)
        ));

        // Generate enum types first (tables may reference them)
        if !entities.enums.is_empty() {
            output.push_str("  // Enums\n");
            for (_, enum_info) in &entities.enums {
                output.push_str(&generate_enum_type(enum_info, config));
            }
            output.push('\n');
        }

        // Generate composite types
        if !entities.composite_types.is_empty() {
            output.push_str("  // Composite Types\n");
            for (_, comp) in &entities.composite_types {
                output.push_str(&generate_composite_type(comp, config, schema));
            }
            output.push('\n');
        }

        // Generate table types
        if !entities.tables.is_empty() {
            output.push_str("  // Tables\n");
            for (_, table) in &entities.tables {
                output.push_str(&generate_table_types(table, config, schema));
            }
        }

        // Generate view types
        if !entities.views.is_empty() {
            output.push_str("  // Views\n");
            for (_, view) in &entities.views {
                output.push_str(&generate_view_type(view, config, schema));
            }
        }

        output.push_str("}\n\n");
    }

    // Generate a Database type that mirrors Supabase's structure
    output.push_str(&generate_database_type(&schemas, schema));

    output
}

#[derive(Default)]
struct SchemaEntities {
    tables: BTreeMap<String, TableInfo>,
    enums: BTreeMap<String, EnumInfo>,
    composite_types: BTreeMap<String, CompositeTypeInfo>,
    views: BTreeMap<String, ViewInfo>,
}

fn normalize_schema_name(schema: &str) -> String {
    schema.trim_matches('"').to_string()
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn to_camel_case(s: &str) -> String {
    let pascal = to_pascal_case(s);
    let mut chars = pascal.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_lowercase().chain(chars).collect(),
    }
}

/// Map PostgreSQL types to TypeScript types.
fn pg_type_to_ts(pg_type: &str, is_nullable: bool, is_array: bool, schema: &DbSchema) -> String {
    let base_type = pg_type
        .trim_matches('"')
        .to_lowercase()
        .replace("[]", "")
        .trim()
        .to_string();

    let ts_type = match base_type.as_str() {
        // Numeric types
        "smallint" | "int2" | "integer" | "int" | "int4" | "bigint" | "int8" | "real"
        | "float4" | "double precision" | "float8" | "numeric" | "decimal" | "money" => "number",

        // Boolean
        "boolean" | "bool" => "boolean",

        // String types
        "text" | "varchar" | "character varying" | "char" | "character" | "name" | "citext" => {
            "string"
        }

        // UUID
        "uuid" => "string",

        // Date/Time types
        "date"
        | "timestamp"
        | "timestamp without time zone"
        | "timestamptz"
        | "timestamp with time zone"
        | "time"
        | "time without time zone"
        | "timetz"
        | "time with time zone"
        | "interval" => "string",

        // JSON types
        "json" | "jsonb" => "Json",

        // Binary
        "bytea" => "string",

        // Network types
        "inet" | "cidr" | "macaddr" | "macaddr8" => "string",

        // Geometric types
        "point" | "line" | "lseg" | "box" | "path" | "polygon" | "circle" => "unknown",

        // Other types
        "void" => "void",
        "record" => "Record<string, unknown>",
        "trigger" => "unknown",

        // Check if it's a known enum type
        _ => {
            // Check if this type matches any enum
            for (key, enum_info) in &schema.enums {
                let enum_name = enum_info.name.to_lowercase();
                if base_type == enum_name || key.to_lowercase().contains(&base_type) {
                    let schema_name = normalize_schema_name(&enum_info.schema);
                    return format_type_with_nullability(
                        &format!(
                            "{}.{}",
                            to_pascal_case(&schema_name),
                            to_pascal_case(&enum_info.name)
                        ),
                        is_nullable,
                        is_array,
                    );
                }
            }
            // Check if it's a composite type
            for (key, comp) in &schema.composite_types {
                let comp_name = comp.name.to_lowercase();
                if base_type == comp_name || key.to_lowercase().contains(&base_type) {
                    let schema_name = normalize_schema_name(&comp.schema);
                    return format_type_with_nullability(
                        &format!(
                            "{}.{}",
                            to_pascal_case(&schema_name),
                            to_pascal_case(&comp.name)
                        ),
                        is_nullable,
                        is_array,
                    );
                }
            }
            "unknown"
        }
    };

    format_type_with_nullability(ts_type, is_nullable, is_array)
}

fn format_type_with_nullability(base_type: &str, is_nullable: bool, is_array: bool) -> String {
    let typed = if is_array {
        format!("{}[]", base_type)
    } else {
        base_type.to_string()
    };

    if is_nullable {
        format!("{} | null", typed)
    } else {
        typed
    }
}

fn generate_enum_type(enum_info: &EnumInfo, config: &TypeScriptConfig) -> String {
    let mut output = String::new();
    let type_name = to_pascal_case(&enum_info.name);

    let export_keyword = if config.export_types { "export " } else { "" };

    // Generate as union type of string literals
    let values: Vec<String> = enum_info
        .values
        .iter()
        .map(|v| format!("'{}'", v))
        .collect();

    output.push_str(&format!(
        "  {}type {} = {};\n",
        export_keyword,
        type_name,
        values.join(" | ")
    ));

    output
}

fn generate_composite_type(
    comp: &CompositeTypeInfo,
    config: &TypeScriptConfig,
    schema: &DbSchema,
) -> String {
    let mut output = String::new();
    let type_name = to_pascal_case(&comp.name);

    let export_keyword = if config.export_types { "export " } else { "" };

    output.push_str(&format!("  {}interface {} {{\n", export_keyword, type_name));

    for attr in &comp.attributes {
        let ts_type = pg_type_to_ts(&attr.data_type, false, false, schema);
        output.push_str(&format!(
            "    {}: {};\n",
            to_camel_case(&attr.name),
            ts_type
        ));
    }

    output.push_str("  }\n");
    output
}

fn generate_table_types(table: &TableInfo, config: &TypeScriptConfig, schema: &DbSchema) -> String {
    let mut output = String::new();
    let table_name = to_pascal_case(&table.table_name);

    let export_keyword = if config.export_types { "export " } else { "" };

    // Sort columns for deterministic output
    let mut columns: Vec<(&String, &ColumnInfo)> = table.columns.iter().collect();
    columns.sort_by(|a, b| a.0.cmp(b.0));

    // Row type (what you get from SELECT)
    if config.generate_row_types {
        output.push_str(&format!(
            "  {}interface {}Row {{\n",
            export_keyword, table_name
        ));
        for (col_name, col_info) in &columns {
            let ts_type = column_to_ts_type(col_info, schema);
            if let Some(comment) = &col_info.comment {
                output.push_str(&format!("    /** {} */\n", comment));
            }
            output.push_str(&format!("    {}: {};\n", col_name, ts_type));
        }
        output.push_str("  }\n\n");
    }

    // Insert type (fields with defaults are optional)
    if config.generate_insert_types {
        output.push_str(&format!(
            "  {}interface {}Insert {{\n",
            export_keyword, table_name
        ));
        for (col_name, col_info) in &columns {
            let ts_type = column_to_ts_type(col_info, schema);
            let is_optional = has_default_value(col_info) || col_info.is_identity;
            let optional_marker = if is_optional { "?" } else { "" };
            output.push_str(&format!(
                "    {}{}: {};\n",
                col_name, optional_marker, ts_type
            ));
        }
        output.push_str("  }\n\n");
    }

    // Update type (all fields optional)
    if config.generate_update_types {
        output.push_str(&format!(
            "  {}interface {}Update {{\n",
            export_keyword, table_name
        ));
        for (col_name, col_info) in &columns {
            let ts_type = column_to_ts_type(col_info, schema);
            output.push_str(&format!("    {}?: {};\n", col_name, ts_type));
        }
        output.push_str("  }\n\n");
    }

    output
}

fn column_to_ts_type(col: &ColumnInfo, schema: &DbSchema) -> String {
    // Check if column uses an enum type
    if let Some(enum_name) = &col.enum_name {
        // Find the enum in the schema
        for (_, enum_info) in &schema.enums {
            if enum_info.name == *enum_name
                || enum_info.name.to_lowercase() == enum_name.to_lowercase()
            {
                let schema_name = normalize_schema_name(&enum_info.schema);
                return format_type_with_nullability(
                    &format!(
                        "{}.{}",
                        to_pascal_case(&schema_name),
                        to_pascal_case(&enum_info.name)
                    ),
                    col.is_nullable,
                    col.is_array,
                );
            }
        }
    }

    pg_type_to_ts(&col.data_type, col.is_nullable, col.is_array, schema)
}

fn has_default_value(col: &ColumnInfo) -> bool {
    col.column_default.is_some()
}

fn generate_view_type(view: &ViewInfo, config: &TypeScriptConfig, schema: &DbSchema) -> String {
    let mut output = String::new();
    let view_name = to_pascal_case(&view.name);

    let export_keyword = if config.export_types { "export " } else { "" };

    output.push_str(&format!(
        "  {}interface {}Row {{\n",
        export_keyword, view_name
    ));

    // Sort columns for deterministic output
    let mut columns: Vec<_> = view.columns.iter().collect();
    columns.sort_by(|a, b| a.name.cmp(&b.name));

    for col in columns {
        let ts_type = pg_type_to_ts(&col.data_type, true, false, schema); // View columns are typically nullable
        if let Some(comment) = &col.comment {
            output.push_str(&format!("    /** {} */\n", comment));
        }
        output.push_str(&format!("    {}: {};\n", col.name, ts_type));
    }

    output.push_str("  }\n\n");
    output
}

fn generate_database_type(schemas: &BTreeMap<String, SchemaEntities>, schema: &DbSchema) -> String {
    let mut output = String::new();

    output.push_str("// Database type compatible with Supabase client\n");
    output.push_str("export interface Database {\n");

    for (schema_name, entities) in schemas {
        let pascal_schema = to_pascal_case(schema_name);
        output.push_str(&format!("  {}: {{\n", schema_name));

        // Tables
        output.push_str("    Tables: {\n");
        for (_, table) in &entities.tables {
            let table_pascal = to_pascal_case(&table.table_name);
            output.push_str(&format!("      {}: {{\n", table.table_name));
            output.push_str(&format!(
                "        Row: {}.{}Row;\n",
                pascal_schema, table_pascal
            ));
            output.push_str(&format!(
                "        Insert: {}.{}Insert;\n",
                pascal_schema, table_pascal
            ));
            output.push_str(&format!(
                "        Update: {}.{}Update;\n",
                pascal_schema, table_pascal
            ));
            output.push_str("      };\n");
        }
        output.push_str("    };\n");

        // Views
        output.push_str("    Views: {\n");
        for (_, view) in &entities.views {
            let view_pascal = to_pascal_case(&view.name);
            output.push_str(&format!("      {}: {{\n", view.name));
            output.push_str(&format!(
                "        Row: {}.{}Row;\n",
                pascal_schema, view_pascal
            ));
            output.push_str("      };\n");
        }
        output.push_str("    };\n");

        // Functions placeholder (can be expanded)
        output.push_str("    Functions: {\n");
        // Add function signatures if needed
        for (key, func) in &schema.functions {
            if normalize_schema_name(&func.schema) == *schema_name {
                output.push_str(&format!("      // {}\n", key));
            }
        }
        output.push_str("    };\n");

        // Enums
        output.push_str("    Enums: {\n");
        for (_, enum_info) in &entities.enums {
            let enum_pascal = to_pascal_case(&enum_info.name);
            output.push_str(&format!(
                "      {}: {}.{};\n",
                enum_info.name, pascal_schema, enum_pascal
            ));
        }
        output.push_str("    };\n");

        // Composite Types
        output.push_str("    CompositeTypes: {\n");
        for (_, comp) in &entities.composite_types {
            let comp_pascal = to_pascal_case(&comp.name);
            output.push_str(&format!(
                "      {}: {}.{};\n",
                comp.name, pascal_schema, comp_pascal
            ));
        }
        output.push_str("    };\n");

        output.push_str("  };\n");
    }

    output.push_str("}\n\n");

    // Add Json type helper
    output.push_str("// Helper types\n");
    output.push_str("export type Json =\n");
    output.push_str("  | string\n");
    output.push_str("  | number\n");
    output.push_str("  | boolean\n");
    output.push_str("  | null\n");
    output.push_str("  | { [key: string]: Json | undefined }\n");
    output.push_str("  | Json[];\n");

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;

    #[test]
    fn test_pg_type_to_ts_basic() {
        let schema = DbSchema::default();

        assert_eq!(pg_type_to_ts("integer", false, false, &schema), "number");
        assert_eq!(pg_type_to_ts("text", false, false, &schema), "string");
        assert_eq!(pg_type_to_ts("boolean", false, false, &schema), "boolean");
        assert_eq!(pg_type_to_ts("uuid", false, false, &schema), "string");
        assert_eq!(pg_type_to_ts("jsonb", false, false, &schema), "Json");
    }

    #[test]
    fn test_pg_type_to_ts_nullable() {
        let schema = DbSchema::default();

        assert_eq!(
            pg_type_to_ts("integer", true, false, &schema),
            "number | null"
        );
        assert_eq!(pg_type_to_ts("text", true, false, &schema), "string | null");
    }

    #[test]
    fn test_pg_type_to_ts_array() {
        let schema = DbSchema::default();

        assert_eq!(pg_type_to_ts("integer", false, true, &schema), "number[]");
        assert_eq!(pg_type_to_ts("text", false, true, &schema), "string[]");
        assert_eq!(
            pg_type_to_ts("integer", true, true, &schema),
            "number[] | null"
        );
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("user_profile"), "UserProfile");
        assert_eq!(to_pascal_case("public"), "Public");
        assert_eq!(to_pascal_case("my_cool_table"), "MyCoolTable");
    }

    #[test]
    fn test_generate_enum_type() {
        let enum_info = EnumInfo {
            schema: "public".to_string(),
            name: "status".to_string(),
            values: vec![
                "pending".to_string(),
                "active".to_string(),
                "completed".to_string(),
            ],
        };

        let config = TypeScriptConfig::default();
        let result = generate_enum_type(&enum_info, &config);

        assert!(result.contains("export type Status"));
        assert!(result.contains("'pending'"));
        assert!(result.contains("'active'"));
        assert!(result.contains("'completed'"));
    }

    #[test]
    fn test_generate_typescript_full() {
        use crate::schema::ColumnInfo;

        let mut schema = DbSchema::default();

        // Add an enum
        schema.enums.insert(
            "\"public\".\"status\"".to_string(),
            EnumInfo {
                schema: "public".to_string(),
                name: "status".to_string(),
                values: vec!["pending".to_string(), "active".to_string()],
            },
        );

        // Add a table
        let mut columns = HashMap::new();
        columns.insert(
            "id".to_string(),
            ColumnInfo {
                column_name: "id".to_string(),
                data_type: "uuid".to_string(),
                is_nullable: false,
                column_default: Some("gen_random_uuid()".to_string()),
                udt_name: "uuid".to_string(),
                is_primary_key: true,
                is_unique: false,
                is_identity: false,
                identity_generation: None,
                is_generated: false,
                generation_expression: None,
                collation: None,
                enum_name: None,
                is_array: false,
                comment: None,
            },
        );
        columns.insert(
            "name".to_string(),
            ColumnInfo {
                column_name: "name".to_string(),
                data_type: "text".to_string(),
                is_nullable: false,
                column_default: None,
                udt_name: "text".to_string(),
                is_primary_key: false,
                is_unique: false,
                is_identity: false,
                identity_generation: None,
                is_generated: false,
                generation_expression: None,
                collation: None,
                enum_name: None,
                is_array: false,
                comment: None,
            },
        );

        schema.tables.insert(
            "\"public\".\"users\"".to_string(),
            TableInfo {
                schema: "public".to_string(),
                table_name: "users".to_string(),
                columns,
                foreign_keys: vec![],
                indexes: vec![],
                triggers: vec![],
                rls_enabled: false,
                policies: vec![],
                check_constraints: vec![],
                comment: None,
            },
        );

        let config = TypeScriptConfig::default();
        let result = generate_typescript(&schema, &config);

        assert!(result.contains("export namespace Public"));
        assert!(result.contains("interface UsersRow"));
        assert!(result.contains("interface UsersInsert"));
        assert!(result.contains("interface UsersUpdate"));
        assert!(result.contains("type Status"));
        assert!(result.contains("interface Database"));
    }
}
